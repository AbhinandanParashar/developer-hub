---
id: sqlfile
title: What is sqlFile?
description: Learn how the sqlFile tag works in Harness DB DevOps (via Liquibase), and how it enables reuse of raw SQL for reliable, auditable database deployments.
slug: /database-devops/concepts/glossary/sqlfile
sidebar_label: sqlFile
keywords:
  - sqlFile
  - liquibase
  - changeset
  - raw SQL
  - database deployments
  - database automation
  - rollback
  - harness database devops
---

import Head from '@docusaurus/Head';

<Head>
  <meta name="title" content="Understanding sqlFile in Harness Database DevOps" data-rh="title"/>
  <meta
    name="description"
    content="Learn how the sqlFile tag works in Harness DB DevOps (via Liquibase), and how it enables reuse of raw SQL for reliable, auditable database deployments."
  />
</Head>

The **`sqlFile`** tag in Harness Database DevOps (which uses Liquibase under the hood) allows you to execute raw SQL stored in external `.sql` files as part of a [changeset](./context.md). This is especially useful for large SQL scripts, vendor-specific features, or when reusing validated scripts across environments.

Here’s a sample usage within a changeset:

```yaml
databaseChangeLog:
  - changeSet:
      id: run-import-script
      author: db.team
      changes:
        - sqlFile:
            path: scripts/init_data.sql
            splitStatements: true
            stripComments: true
            encoding: UTF-8
```

## Key Attributes of `sqlFile`

The `sqlFile` tag has the following key attributes:

| Attribute         | Description                                                                     | Required |
| ----------------- | ------------------------------------------------------------------------------- | -------- |
| `path`            | Relative or absolute path to the SQL file to be executed.                       | ✅        |
| `splitStatements` | Whether the file should be split into individual SQL statements. Default: true. | ❌        |
| `stripComments`   | Strips SQL comments before execution. Default: false.                           | ❌        |
| `encoding`        | Character encoding of the file (e.g., `UTF-8`).                                 | ❌        |
| `endDelimiter`    | Defines custom delimiter for statements (if `splitStatements` is true).         | ❌        |

## Why Use sqlFile?

- Maintain large scripts outside the changelog for better readability and reuse.
- Reuse approved SQL written by DBAs or generated by third-party tools.
- Improve traceability by linking SQL execution to a versioned [changeset](./changeset.md) with author and context.
- Enforce auditability via Harness pipelines, approvals, and deployment logs.

## Best Practices in Harness
Place `.sql` files in version control alongside your changelogs.
Pair each sqlFile with a rollback block if the operation is reversible.
Use context, labels, and logicalFilePath for environment-specific execution and clarity.

### Example with Rollback

```yml
- changeSet:
    id: seed-customers
    author: alice.dev
    context: dev
    changes:
      - sqlFile:
          path: seed/customers.sql
          splitStatements: true
    rollback:
      sqlFile:
        path: rollback/delete_customers.sql
```

This example shows how to use `sqlFile` to seed data in a development environment, with a corresponding rollback script to remove the seeded data if needed.

## Harness-Specific Enhancements
While sqlFile follows Liquibase OSS conventions, Harness adds:

- SQL preview during PRs and pipeline runs
- Approvals tied to the SQL output
- Change tracking and audit logs across environments
- Rollback automation using companion rollback scripts or failover logic

## When Should You Avoid sqlFile?
- For small, single DDL statements—prefer inline changes for readability.
- When portability is critical—SQL in files may be tightly coupled to a specific dialect.

## Conclusion

The sqlFile tag enables teams to execute and manage raw SQL in a structured, controlled, and auditable way through Harness Database DevOps. It bridges manual DBA processes with modern CI/CD pipelines, empowering teams to scale database automation without sacrificing control or compliance.

## FAQ

### 1. **What is the `sqlFile` tag used for in Harness Database DevOps?**

The `sqlFile` tag lets you execute raw SQL stored in external files as part of a Liquibase changeset. In Harness Database DevOps, it is used to version and run large SQL scripts—like data imports or vendor-specific DDL—within a CI/CD pipeline, while retaining auditability and rollback options.

### 2. **Can I preview the SQL inside a `sqlFile` before deployment?**

Yes. Harness automatically previews the contents of `sqlFile` executions during pull requests and pipeline runs. This visibility ensures DBAs and reviewers can validate the exact SQL that will be executed, reducing risk and improving governance.

### 3. **How does rollback work with `sqlFile` in Harness?**

To enable rollback, you can define a companion `sqlFile` under the `rollback` section of the changeset. Harness will automatically trigger this rollback SQL if the deployment fails or is manually rolled back, ensuring consistent and safe recovery.

### 4. **Where should I store `.sql` files used by `sqlFile`?**

Store your `.sql` files in version control alongside your changelogs. This ensures traceability, supports GitOps workflows, and allows Harness to track file changes, validate checksums, and enforce pipeline approvals.

### 5. **Is `sqlFile` better than inline SQL in Liquibase changesets?**

Use `sqlFile` when:

* The SQL is too large or complex for inline syntax.
* You’re reusing scripts written or approved by DBAs.
* You need to preserve dialect-specific formatting.

For smaller, portable, or declarative changes, inline YAML or XML is preferred.

### 6. **Does Harness support approvals for `sqlFile` execution?**

Absolutely. Harness integrates approval gates into your database pipeline. Any changeset using `sqlFile` can be subjected to review and approval workflows—ensuring that all SQL changes are vetted before execution in sensitive environments like staging or production.
