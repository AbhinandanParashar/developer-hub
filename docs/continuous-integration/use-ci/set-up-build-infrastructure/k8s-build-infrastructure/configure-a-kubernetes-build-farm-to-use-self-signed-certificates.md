---
title: Configure a Kubernetes build farm to use self-signed certificates
description: CI build pods can interact with servers using self-signed certificates.
sidebar_position: 40
helpdocs_topic_id: e5qkn9atiw
helpdocs_category_id: rg8mrhqm95
helpdocs_is_private: false
helpdocs_is_published: true
---


import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


<DocsTag  text="Team plan" link="/docs/continuous-integration/ci-quickstarts/ci-subscription-mgmt" /> <DocsTag  text="Enterprise plan" link="/docs/continuous-integration/ci-quickstarts/ci-subscription-mgmt" />

CI build infrastructure pods can interact with servers using self-signed certificates. This option is useful for organizations that prefer to use internal certificates instead of certificates generated by a public Certificate Authority (CA).

:::info

* This topic assumes that you are familiar with how to implement SSL in Kubernetes. General information about implementing SSL is outside the scope of this topic.
* With a Kubernetes cluster build infrastructure, all **Build and Push** steps use [kaniko](https://github.com/GoogleContainerTools/kaniko/blob/main/README.md). Kaniko uses the path `/kaniko/ssl/certs/additional-ca-cert-bundle.crt` to read certificates.
* Harness uses a UBI image for the Git Clone step. UBI reads certificates from `/etc/ssl/certs/ca-bundle.crt`.
* Different base images use different paths as their default certificate location. For example, Alpine images use this path to recognize certificates: `/etc/ssl/certs/ca-certificates.crt` For any other image, make sure you verify the default certificate path.

:::

## Enable self-signed certificates

1. Create a Kubernetes secret or config map with the required certificates in the same namespace used by the Harness delegate. For example:

   ```yaml
   apiVersion: v1  
   kind: Secret  
   metadata:  
     name: addcerts  
     namespace: harness-delegate-ng  
   type: Opaque  
   stringData:                             
     ca.bundle: |  
       -----BEGIN CERTIFICATE-----  
       XXXXXXXXXXXXXXXXXXXXXXXXXXX  
       -----END CERTIFICATE-------  
       -----BEGIN CERTIFICATE-----  
       XXXXXXXXXXXXXXXXXXXXXXXXXXX  
       -----END CERTIFICATE-------
   ```

2. Mount the secret as a `volume` on the delegate pod and add a `volumeMount` to your certificate files at `/opt/harness-delegate/ca-bundle`.

   For instructions, go to [Configuring a Pod to Use a Volume for Storage](https://kubernetes.io/docs/tasks/configure-pod-container/configure-volume-storage/) in the Kubernetes docs.

   Here's an example: 

   ```yaml
    spec:
      containers:
      - image: harness/delegate:yy.mm.verno
        volumeMounts:  
        - name: certvol  
          mountPath: /opt/harness-delegate/ca-bundle/ca.bundle
          subPath: ca.bundle 
      volumes:
      - name: certvol  
        secret:  
          secretName: addcerts
          items:  
            - key: ca.bundle  
              path: ca.bundle

   ```

   Both CI build pods and the SCM client on the delegate support this method.

   :::warning

   Make sure the destination path is not same as the default CA certificate path of the corresponding container image.

   If you want to override the default certificate file, make sure the Kubernetes secret or config map (from step one) includes *all* certificates required by the pipelines that will use this build infrastructure.

   :::


3. Restart the delegate. Once it is up and running, `exec` into the container and ensure that the volume exists at the mounted path and contains your certificates.

## Enable self-signed certificates with a self-hosted image registry (advanced)

:::important

This workflow is applicable only if you're using a self-hosted registry to store your container images. For all other workflows, go to [Enable self-signed certificates](#enable-self-signed-certificates). 

:::

1. Create a Kubernetes secret or config map with the required certificates in the same namespace used by the Harness delegate. For example:

   ```yaml
   apiVersion: v1  
   kind: Secret  
   metadata:  
     name: addcerts  
     namespace: harness-delegate-ng  
   type: Opaque  
   stringData:                             
     ca.bundle: |  
       -----BEGIN CERTIFICATE-----  
       XXXXXXXXXXXXXXXXXXXXXXXXXXX  
       -----END CERTIFICATE-------  
       -----BEGIN CERTIFICATE-----  
       XXXXXXXXXXXXXXXXXXXXXXXXXXX  
       -----END CERTIFICATE-------
   ```

2. Mount the secret as a volume on the delegate pod.

   In the delegate pod, you must specify `DESTINATION_CA_PATH`. Provide a comma-separated list of paths in the build pod where you want the certs to be mounted, and mount your certificate files to `opt/harness-delegate/ca-bundle`.

   For instructions, go to [Configuring a Pod to Use a Volume for Storage](https://kubernetes.io/docs/tasks/configure-pod-container/configure-volume-storage/) in the Kubernetes docs.

   Here's an example:

   ```yaml
          env:
          - name: DESTINATION_CA_PATH
            value: "/etc/ssl/certs/ca-bundle.crt,/kaniko/ssl/certs/additional-ca-cert-bundle.crt"
            volumeMounts:
            - name: certvol
              mountPath: /opt/harness-delegate/ca-bundle/ca.bundle
              subPath:  ca.bundle
          volumes:
          - name: certvol
            secret:
               secretName: addcerts
               items:
                - key: ca.bundle
                  path: ca.bundle
   ```

   Both CI build pods and the SCM client on the delegate support this method.

    <details>
    <summary>Legacy: CI_MOUNT_VOLUMES</summary>
      
      Prior to the introduction of `DESTINATION_CA_PATH`, you used `ADDITIONAL_CERTS_PATH` and `CI_MOUNT_VOLUMES` to mount certs.
      
      The legacy method is still supported, but Harness recommends `DESTINATION_CA_PATH`. If you include both, `DESTINATION_CA_PATH` takes precedence. If Harness can't resolve `DESTINATION_CA_PATH`, it falls back to `CI_MOUNT_VOLUMES` and `ADDITIONAL_CERTS_PATH`.

      You must specify both `ADDITIONAL_CERTS_PATH` and `CI_MOUNT_VOLUMES`.

      For `ADDITIONAL_CERTS_PATH`, provide the path to the certificates in the delegate, such as `/tmp/ca.bundle`.

      For `CI_MOUNT_VOLUMES`, provide a comma-separated list of `source:destination` mappings where `source` is the certificate path on the delegate, and `destination` is the path where you want to expose the certificates on the build containers. For example:

      ```
      /tmp/ca.bundle:/etc/ssl/certs/ca-bundle.crt,/tmp/ca.bundle:/kaniko/ssl/certs/additional-ca-cert-bundle.crt
      ```

      The `CI_MOUNT_VOLUMES` list must include *all* certificates that your build containers need to interact with external services.

      ```yaml
            spec:
              containers:
                - image: harness/delegate:yy.mm.verno
                  env:  
                    - name: ADDITIONAL_CERTS_PATH  
                      value: /tmp/ca.bundle  
                    - name: CI_MOUNT_VOLUMES  
                      value: "/tmp/ca.bundle:/etc/ssl/certs/ca-bundle.crt,/tmp/ca.bundle:/kaniko/ssl/certs/additional-ca-cert-bundle.crt"  
                  volumeMounts:  
                    - name: certvol  
                      mountPath: /tmp/ca.bundle  
                      subPath:  ca.bundle 
              volumes:  
                - name: certvol  
                  secret:  
                    secretName: addcerts  
                    items:  
                    - key: ca.bundle  
                      path: ca.bundle
      ```

    </details>

   :::warning

   Make sure the destination path is not same as the default CA certificate path of the corresponding container image.

   If you want to override the default certificate file, make sure the Kubernetes secret or config map (from step one) includes *all* certificates required by the pipelines that will use this build infrastructure.

   :::

3. If you're storing your certificates in a local registry and [need to run Docker-in-Docker](/docs/security-testing-orchestration/sto-techref-category/security-step-settings-reference#docker-in-docker-requirements-for-sto), specify the local certificate path on the delegate.

   Suppose your self-signed certs are stored at `https://my-registry.local.org:799` and you log in like this:

   `docker login my-registry.local.org:799`

   In this case, you'd add the path to your `DESTINATION_CA_PATH` environment like this:
 
     ```yaml
          env:
          - name: DESTINATION_CA_PATH
            value: "/etc/docker/certs.d/my-registry.local.org:799/ca.crt,/etc/ssl/certs/ca-bundle.crt,/kaniko/ssl/certs/additional-ca-cert-bundle.crt"
            volumeMounts:
            - name: certvol
              mountPath: /opt/harness-delegate/ca-bundle/ca.bundle
              subPath:  ca.bundle
          volumes:
          - name: certvol
            secret:
               secretName: addcerts
               items:
                - key: ca.bundle
                  path: ca.bundle
   ```


4. Restart the delegate. Once it's' up and running, `exec` into the container and ensure that the volume exists at the mounted path and contains your certificates.

## Troubleshoot Kubernetes cluster build infrastructures

Go to the [CI Knowledge Base](/kb/continuous-integration/continuous-integration-faqs) for questions and issues related to Kubernetes cluster build infrastructures, including use of self-signed certificates, such as:

* [SCM service connection issues](/kb/continuous-integration/continuous-integration-faqs/#git-connector-scm-connection-errors-when-using-self-signed-certificates)
* [How do I make internal CA certs available to the delegate pod?](/kb/continuous-integration/continuous-integration-faqs/#how-do-i-make-internal-ca-certs-available-to-the-delegate-pod)
* [Where should I mount internal CA certs on the build pod?](/kb/continuous-integration/continuous-integration-faqs/#where-should-i-mount-internal-ca-certs-on-the-build-pod)
* [Certificate volumes aren't mounted to the build pod](/kb/continuous-integration/continuous-integration-faqs/#certificate-volumes-arent-mounted-to-the-build-pod)
